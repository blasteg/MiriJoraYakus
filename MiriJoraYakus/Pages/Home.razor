@page "/"
@using MiriJoraYakus.Enums
@using MiriJoraYakus.Data
@inject IJSRuntime JsRuntime
<style>
    img.cardGrid {
        max-width: 100%;
        height: auto;
        max-height: 100%;
    }

    img.dimmed {
        filter: brightness(25%)
    }

    img.unseen {
        filter: opacity(0.4)
    }
</style>
<PageTitle>Home</PageTitle>

<h1>Hello, world!</h1>
<table>
    <tr>
        @for (int i = 0; i < maxHandSize; i++)
        {
            int n = i;
            <td>
                <img class="cardGrid" src=@("/IdolIcons/"+ (int)(hand.Count>i?hand.ElementAt(n):0)+".png")
                     @onclick="()=>RemoveFromHand(n)" />
            </td>
        }
    </tr>
</table>
Welcome to your new app.
<hr>
<table style=" width:100%">
    @for (int i = 0; i < totalCards / perRow; i++)
    {
        <tr>
            @for (int j = 0; j < perRow; j++)
            {
                int n = i * perRow + j + 1;
                if (n <= totalCards)
                {
                    <td>
                        <img class="cardGrid @(available[(CardEnum)n]?"normal":"dimmed")" src=@("/IdolIcons/"+(n)+".png")
                             @oncontextmenu="()=>ToggleAvailable(n)" @oncontextmenu:preventDefault="true" @onclick="()=>AddToHand(n)" />
                    </td>
                }
            }
        </tr>
    }
</table>
@foreach (var groups in potentialUnits.GroupBy(x=>x.TotalCount).OrderByDescending(x=>x.Key))
{
    <br />
<table>
        @foreach (var a in groups.OrderBy(x => x.Gone).ThenByDescending(x => x.Have))
    {
        <tr>
            <td>@a?.Name <br /> @a?.Have / @a?.TotalCount</td>
            @foreach (var b in a?.Idols ?? new List<CardEnum>())
            {
                <td>
                    <img class="cardGrid @(hand.Any(x=>x==b)?"normal" : available[b]? "unseen" : "dimmed" )" src=@("/IdolIcons/"+ (int)(b)+".png") />
                </td>
            }
        </tr>
    }
</table>
}
@code {
    List<CardEnum> hand = new List<CardEnum>();
    private int maxHandSize = 9;
    private int totalCards = 52;
    private int perRow = 13;
    private Dictionary<CardEnum, bool> available = new Dictionary<CardEnum, bool>();
    private List<UnitEvaluator> potentialUnits = new List<UnitEvaluator>();
    protected override async Task OnInitializedAsync()
    {
        foreach (CardEnum a in Enum.GetValues(typeof(CardEnum)))
        {
            available[a] = true;
        }
        GlobalDatas.BaseUnitData.ForEach(x => potentialUnits.Add(new UnitEvaluator(x)));
    }
    private void ToggleAvailable(int n)
    {
        available[(CardEnum)n] = !available[(CardEnum)n];
        hand.RemoveAll(x => x == (CardEnum)n);
        EvaluateHand();
        StateHasChanged();
    }
    private void AddToHand(int n)
    {
        if (hand.Count >= maxHandSize)
        {
            JsRuntime.InvokeVoidAsync("alert", "Hand is Full");
            return;
        }
        else
        {
            if (available[(CardEnum)n])
            {
                hand.Add((CardEnum)n);
                EvaluateHand();
                StateHasChanged();
            }
        }
    }
    private void RemoveFromHand(int n)
    {
        if (hand.Count > n)
        {
            hand.RemoveAt(n);
            EvaluateHand();
        }
    }
    private void EvaluateHand()
    {
        potentialUnits.ForEach(x =>
        {
            var ownedCards = hand.Intersect(x.Idols).ToList();
            x.Have = ownedCards.Count;
            ownedCards.ForEach(y => x.TypeHave[y.Type()]++);
            x.Gone = x.Idols.Count(y => available[y] == false);
        });
    }
}